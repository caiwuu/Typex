<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: core/view/vdom/patch.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: core/view/vdom/patch.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/*
 * @Author: caiwu
 * @Description:
 * @CreateDate:
 * @LastEditor:
 * @LastEditTime: 2022-11-22 16:20:40
 */
import { default as h, insertedInsQueue } from './createVnode'
import plugins from '@/core/plugins'
import { getVnOrElm, getVnOrIns, setVnElm, setVnIns } from '../../mappings'
import { isUndef, isDef } from '../../utils'

/**
 * @description 判断是否相同节点
 * @param {*} vnode
 * @param {*} oldVnode
 * @returns {*}  
 */
function sameVnode (vnode, oldVnode) {
  return vnode?.key === oldVnode?.key &amp;&amp; vnode?.type === oldVnode?.type
}

/**
 * @description 在老节点中查找id
 * @param {*} node
 * @param {*} oldCh
 * @param {*} start
 * @param {*} end
 * @returns {*}  
 */
function findIdxInOld (node, oldCh, start, end) {
  for (let i = start; i &lt; end; i++) {
    const c = oldCh[i]
    if (isDef(c) &amp;&amp; sameVnode(node, c)) return i
  }
}

/**
 * @description 生成id映射
 * @param {*} children
 * @param {*} beginIdx
 * @param {*} endIdx
 * @returns {*}  
 */
function createKeyToOldIdx (children, beginIdx, endIdx) {
  const map = {}
  for (let i = beginIdx; i &lt;= endIdx; ++i) {
    const key = children[i]?.key
    if (isDef(key)) {
      map[key] = i
    }
  }
  return map
}

/**
 * @description 增加节点
 * @param {*} parentElm
 * @param {*} [before=null]
 * @param {*} vnodes
 * @param {*} startIdx
 * @param {*} endIdx
 */
function addVnodes (parentElm, before = null, vnodes, startIdx, endIdx) {
  for (; startIdx &lt;= endIdx; ++startIdx) {
    const ch = vnodes[startIdx]
    if (ch != null) {
      const elm = plugins.platform.createElm(ch)
      // TODO
      setVnElm(elm, ch)
      plugins.platform.insertBefore(parentElm, elm, before)
    }
  }
}

/**
 * @description 销毁钩子调用
 * @param {*} vnode
 * @param {*} destoryQueue
 */
function invokeDestroyHook (vnode, destoryQueue) {
  const vn = vnode.ins ? getVnOrIns(vnode.ins) : vnode
  if (vn !== undefined) {
    const ins = getVnOrIns(vn)
    ins?.onBeforeUnmount?.()
    if (vn.children !== undefined) {
      for (let j = 0; j &lt; vn.children.length; ++j) {
        const child = vn.children[j]
        if (child != null &amp;&amp; typeof child !== 'string') {
          invokeDestroyHook(child, destoryQueue)
        }
      }
    }
    // 销毁映射
    if (ins) {
      destoryQueue.push(ins)
    }
  }
}

/**
 * @description 节点删除
 * @param {*} parentElm
 * @param {*} oldCh
 * @param {*} startIdx
 * @param {*} endIdx
 */
function removeVnodes (parentElm, oldCh, startIdx, endIdx) {
  for (; startIdx &lt;= endIdx; ++startIdx) {
    const vnode = oldCh[startIdx]
    if (vnode != null) {
      let destoryQueue = []
      // const dom = getVnOrElm(vnode)
      let dom = getVnOrElm(vnode)
      if (!dom) dom = getVnOrElm(getVnOrIns(vnode.ins || {}))
      dom &amp;&amp; plugins.platform.removeChild(parentElm, dom)
      invokeDestroyHook(vnode, destoryQueue)
      destoryQueue.forEach((ins) => {
        ins.onUnmounted?.()
      })
      destoryQueue = null
    }
  }
}

/**
 * @description children更新函数
 * @param {*} parentElm
 * @param {*} newCh
 * @param {*} oldCh
 */
function updateChildren (parentElm, newCh, oldCh) {
  let oldStartIdx = 0
  let newStartIdx = 0
  let oldEndIdx = oldCh.length - 1
  let newEndIdx = newCh.length - 1
  let oldStartVnode = oldCh[0]
  let newStartVnode = newCh[0]
  let oldEndVnode = oldCh[oldEndIdx]
  let newEndVnode = newCh[newEndIdx]
  let oldKeyToIdx
  let idxInOld
  let elmToMove
  let before
  while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) {
    if (oldStartVnode == null) {
      oldStartVnode = oldCh[++oldStartIdx] // Vnode might have been moved left
    } else if (oldEndVnode == null) {
      oldEndVnode = oldCh[--oldEndIdx]
    } else if (newStartVnode == null) {
      newStartVnode = newCh[++newStartIdx]
    } else if (newEndVnode == null) {
      newEndVnode = newCh[--newEndIdx]
      // 新头=旧头
    } else if (sameVnode(newStartVnode, oldStartVnode)) {
      patchVnode(newStartVnode, oldStartVnode)
      oldStartVnode = oldCh[++oldStartIdx]
      newStartVnode = newCh[++newStartIdx]
      // 新尾=旧尾
    } else if (sameVnode(newEndVnode, oldEndVnode)) {
      patchVnode(newEndVnode, oldEndVnode)
      oldEndVnode = oldCh[--oldEndIdx]
      newEndVnode = newCh[--newEndIdx]
      // 旧头=新尾
    } else if (sameVnode(newEndVnode, oldStartVnode)) {
      // Vnode moved right
      patchVnode(newEndVnode, oldStartVnode)
      plugins.platform.insertBefore(
        parentElm,
        getVnOrElm(oldStartVnode),
        getVnOrElm(oldEndVnode).nextSibling
      )
      oldStartVnode = oldCh[++oldStartIdx]
      newEndVnode = newCh[--newEndIdx]
      // 新头=旧尾
    } else if (sameVnode(newStartVnode, oldEndVnode)) {
      // Vnode moved left
      patchVnode(newStartVnode, oldEndVnode)
      plugins.platform.insertBefore(parentElm, getVnOrElm(oldEndVnode), getVnOrElm(oldStartVnode))
      oldEndVnode = oldCh[--oldEndIdx]
      newStartVnode = newCh[++newStartIdx]
    } else {
      if (oldKeyToIdx === undefined) {
        oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
      }
      idxInOld = isDef(newStartVnode.key)
        ? oldKeyToIdx[newStartVnode.key]
        : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx)
      if (isUndef(idxInOld)) {
        // New element
        plugins.platform.insertBefore(
          parentElm,
          plugins.platform.createElm(newStartVnode),
          getVnOrElm(oldStartVnode)
        )
      } else {
        elmToMove = oldCh[idxInOld]
        if (elmToMove.tagName !== newStartVnode.tagName) {
          plugins.platform.insertBefore(
            parentElm,
            plugins.platform.createElm(newStartVnode),
            getVnOrElm(oldStartVnode)
          )
        } else {
          patchVnode(newStartVnode, elmToMove)
          oldCh[idxInOld] = undefined
          plugins.platform.insertBefore(parentElm, getVnOrElm(elmToMove), getVnOrElm(oldStartVnode))
        }
      }
      newStartVnode = newCh[++newStartIdx]
    }
  }

  if (newStartIdx &lt;= newEndIdx) {
    before = newCh[newEndIdx + 1] == null ? null : getVnOrElm(newCh[newEndIdx + 1])
    addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)
  }
  if (oldStartIdx &lt;= oldEndIdx) {
    removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
  }
}

/**
 * @description 节点比对
 * @param {*} vnode
 * @param {*} oldVnode
 */
function patchVnode (vnode, oldVnode) {
  if (oldVnode === vnode) return
  if (typeof vnode.type === 'function') {
    if (vnode.type.isComponent) {
      // 常规组件
      const ins = (vnode.ins = oldVnode.ins)
      ins._$pv = vnode
      const oldVn = getVnOrIns(ins)
      ins.props = Object.freeze({ ...vnode.props })
      const newVn = ins.render(h)
      patchVnode(newVn, oldVn)
    } else {
      // 函数组件
      const oldVn = getVnOrIns(oldVnode)
      const newVn = vnode.type(h, vnode.props)
      setVnIns(vnode, newVn)
      patchVnode(newVn, oldVn)
    }
  } else if (vnode.type === 'text') {
    const elm = getVnOrElm(oldVnode)
    setVnElm(elm, vnode)
    plugins.platform.updateProps(vnode, oldVnode)
  } else {
    // 重新映射elm和vn
    const elm = getVnOrElm(oldVnode)
    setVnElm(elm, vnode)
    // 如果有ins则重新映射ins
    const ins = getVnOrIns(oldVnode)
    ins &amp;&amp; setVnIns(vnode, ins)
    const oldCh = oldVnode.children
    const ch = vnode.children
    plugins.platform.updateProps(vnode, oldVnode)
    if (oldCh !== ch) updateChildren(elm, ch, oldCh)
  }
}

/**
 * @description diff函数
 * @export
 * @param {*} vnode
 * @param {*} oldVnode
 * @returns {*}  
 */
export default function patch (vnode, oldVnode) {
  insertedInsQueue.length = 0
  // 没有oldvnode 直接创建新dom
  if (isUndef(oldVnode)) {
    const elm = plugins.platform.createElm(vnode)
    setVnElm(elm, vnode)
    return elm
  }
  const isRealElment = isDef(oldVnode.nodeType)
  // oldvnode 是dom，先转化为虚拟节点
  if (isRealElment) {
    const elm = oldVnode
    oldVnode = plugins.platform.domToVNode(oldVnode)
    setVnElm(elm, oldVnode)
  }
  // 相同节点则执行更新逻辑
  if (sameVnode(vnode, oldVnode)) {
    patchVnode(vnode, oldVnode)
  } else {
    let oldElm = getVnOrElm(oldVnode)
    const newElm = plugins.platform.createElm(vnode)
    plugins.platform.replaceChild(oldElm.parentNode, newElm, oldElm)
    oldElm = null
  }
  insertedInsQueue.forEach((ele) => {
    if (ele.onMounted) ele.onMounted()
  })
  insertedInsQueue.length = 0
  return getVnOrElm(vnode)
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Component.html">Component</a></li><li><a href="Content.html">Content</a></li><li><a href="Formater.html">Formater</a></li><li><a href="Path.html">Path</a></li><li><a href="Range.html">Range</a></li><li><a href="Selection.html">Selection</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Element">Element</a></li><li><a href="global.html#_genChildren">_genChildren</a></li><li><a href="global.html#addVnodes">addVnodes</a></li><li><a href="global.html#contentDelete">contentDelete</a></li><li><a href="global.html#createKeyToOldIdx">createKeyToOldIdx</a></li><li><a href="global.html#createPath">createPath</a></li><li><a href="global.html#defer">defer</a></li><li><a href="global.html#del">del</a></li><li><a href="global.html#enter">enter</a></li><li><a href="global.html#findIdxInOld">findIdxInOld</a></li><li><a href="global.html#flush">flush</a></li><li><a href="global.html#horizontalMove">horizontalMove</a></li><li><a href="global.html#initDispatcher">initDispatcher</a></li><li><a href="global.html#input">input</a></li><li><a href="global.html#inputText">inputText</a></li><li><a href="global.html#invokeDestroyHook">invokeDestroyHook</a></li><li><a href="global.html#isSameLine">isSameLine</a></li><li><a href="global.html#loop">loop</a></li><li><a href="global.html#patchVnode">patchVnode</a></li><li><a href="global.html#positionCompare">positionCompare</a></li><li><a href="global.html#queryCommonPath">queryCommonPath</a></li><li><a href="global.html#queryPath">queryPath</a></li><li><a href="global.html#queryPathByElm">queryPathByElm</a></li><li><a href="global.html#queryPathByPosition">queryPathByPosition</a></li><li><a href="global.html#queryPathByVn">queryPathByVn</a></li><li><a href="global.html#queryRootPath">queryRootPath</a></li><li><a href="global.html#removeVnodes">removeVnodes</a></li><li><a href="global.html#renderRoot">renderRoot</a></li><li><a href="global.html#sameVnode">sameVnode</a></li><li><a href="global.html#transformOps">transformOps</a></li><li><a href="global.html#updateChildren">updateChildren</a></li><li><a href="global.html#verticalMove">verticalMove</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.2</a> on Sun Mar 19 2023 16:22:34 GMT+0000 (Coordinated Universal Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
